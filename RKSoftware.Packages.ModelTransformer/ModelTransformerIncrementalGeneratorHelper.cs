using System.Text;
using Microsoft.CodeAnalysis;

namespace RKSoftware.Packages.ModelTransformer;

internal static class ModelTransformerIncrementalGeneratorHelper
{
    public const string AttributeNamespace = "RKSoftware.Packages.ModelTransformer.Attributes";
    public const string AttributeName = "ModelTransformerRegistrationAttribute";
    public const string AttributeGenericName = $"{AttributeName}<T1, T2>";

    public const string Attribute = @$"
// <auto-generated>
#nullable enable

namespace {AttributeNamespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public sealed class {AttributeGenericName} : System.Attribute
    {{
    }}
}}";

    public static string GenerateExtensionClass (string hostNamespace, INamedTypeSymbol attr)
    {
        var source = attr.TypeArguments.First();
        var target = attr.TypeArguments.Last();

        var variableCreationCode = string.Empty;
        var methodsCode = string.Empty;
        var variableMappingCode = string.Empty;

        var mappings = GeneratePropertyMappings(source, target);

        if (mappings.Count > 0)
        {
            variableCreationCode = mappings.Select(x => x.VariableCreationCode).Aggregate((a, b) => a.AppendLine(b.ToString())).ToString();
            methodsCode = mappings.Select(x => x.MethodCode).Aggregate((a, b) => a.AppendLine(b.ToString())).ToString();
            variableMappingCode = mappings.Select(x => x.VariableMappingCode).Aggregate((a, b) => a.AppendLine(b.ToString())).ToString();
        }

        var str = $@"
// <auto-generated>
#nullable enable

namespace {hostNamespace}
{{
    public static partial class {source.Name}Extensions
    {{
        public static {target.ToDisplayString()} Transform(this {source.ToDisplayString()} source)
        {{
            if (source == null) 
            {{
                throw new System.ArgumentNullException(nameof(source));
            }}

{variableCreationCode}
            var target = new {target.ToDisplayString()}
            {{
{variableMappingCode}
            }};
            return target;
        }}

{methodsCode}
    }}
    
}}";
        return str;
    }

    private static List<PropertyMappingModel> GeneratePropertyMappings(ITypeSymbol source, ITypeSymbol target)
    {
        var mappings = new List<PropertyMappingModel>();
        foreach (var sourceProp in source.GetMembers().OfType<IPropertySymbol>())
        {
            var targetProp = target.GetMembers()
                .OfType<IPropertySymbol>()
                .FirstOrDefault(p => p.Name == sourceProp.Name && SymbolEqualityComparer.Default.Equals(p.Type, sourceProp.Type));
            if (targetProp != null && !sourceProp.IsStatic && !targetProp.IsStatic && targetProp.SetMethod != null)
            {
                var mapping = new PropertyMappingModel
                {
                    PropertyName = targetProp.Name,
                    VariableName = StringHelper.LowerCaseFirstLetter(targetProp.Name)
                };
                
                var defaultMethodName = $"To{mapping.PropertyName}Default";
                var methodName = $"To{mapping.PropertyName}";

                mapping.VariableCreationCode.AppendLine($"          var {mapping.VariableName} = {defaultMethodName}(source);");
                mapping.VariableCreationCode.AppendLine($"          {methodName}(source, ref {mapping.VariableName});");

                mapping.VariableMappingCode.AppendLine($"               {mapping.PropertyName} =  {mapping.VariableName},");

                mapping.MethodCode.AppendLine($@"     private static {targetProp.Type.ToDisplayString()} {defaultMethodName}({source.ToDisplayString()} source)
        {{
            return source.{sourceProp.Name};
        }}");
                mapping.MethodCode.AppendLine(
$@"     static partial void {methodName}({source.ToDisplayString()} source, ref {targetProp.Type.ToDisplayString()} target);");

                mappings.Add(mapping);
            }
        }
        return mappings;
    }
}
