using System.Collections.Frozen;
using Microsoft.CodeAnalysis;
using RKSoftware.Packages.ModelTransformer.Models;

namespace RKSoftware.Packages.ModelTransformer.Generations;

internal static class ModelExtensionGeneration
{
    public static string GenerateExtensionClass(string hostNamespace, AttributeDataModel attr)
    {
        var variableCreationCode = string.Empty;
        var methodsCode = string.Empty;
        var variableMappingCode = string.Empty;

        var mappings = GeneratePropertyMappings(attr);

        if (mappings.Count > 0)
        {
            variableCreationCode = mappings.Select(x => x.VariableCreationCode).Aggregate((a, b) => a.AppendLine(b.ToString())).ToString();
            methodsCode = mappings.Select(x => x.MethodCode).Aggregate((a, b) => a.AppendLine(b.ToString())).ToString();
            variableMappingCode = mappings.Select(x => x.VariableMappingCode).Aggregate((a, b) => a.AppendLine(b.ToString())).ToString();
        }

        var str = $@"
// <auto-generated>
#nullable enable

namespace {hostNamespace}
{{
    public static partial class {attr.Source.Name}Extensions
    {{
        public static {attr.Target.ToDisplayString()} Transform(this {attr.Source.ToDisplayString()} source)
        {{
            if (source == null) 
            {{
                throw new System.ArgumentNullException(nameof(source));
            }}
{variableCreationCode}
            var target = new {attr.Target.ToDisplayString()}
            {{
{variableMappingCode}
            }};
            return target;
        }}
{methodsCode}
    }}    
}}";
        return str;
    }

    #region helpers

    private static List<PropertyMappingModel> GeneratePropertyMappings(AttributeDataModel attr)
    {
        var mappings = new List<PropertyMappingModel>();

        var targetProps = attr.Target.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(x => !x.IsStatic);

        foreach (var targetProp in targetProps)
        {
            IPropertySymbol? sourceProp = null;
            var isIgnored = IsPropertyIgnored(targetProp, attr.IgnoredProperties);
            if (!isIgnored)
            {
                sourceProp = attr.Source.GetMembers()
                    .OfType<IPropertySymbol>()
                    .FirstOrDefault(x => !x.IsStatic && x.Name.Equals(targetProp.Name, StringComparison.Ordinal));
            }
            var mapping = new PropertyMappingModel(targetProp);

            if (!isIgnored)
            {
                if (sourceProp != null)
                {
                    mapping.VariableCreationCode.AppendLine(@$"
            var {mapping.VariableName} = {mapping.DefaultMethodName}(source);
            {mapping.MethodName}(source, ref {mapping.VariableName});");
                }
                else
                {
                    mapping.VariableCreationCode.AppendLine(@$"
            var {mapping.VariableName} = {mapping.MethodName}(source);");
                }
            }

            mapping.VariableMappingCode.Append($@"
                {mapping.PropertyName} = {(isIgnored ? "default" : mapping.VariableName)},");

            if (!isIgnored)
            {
                if (sourceProp != null)
                {
                    mapping.MethodCode.AppendLine($@"
        private static {targetProp.Type.ToDisplayString()} {mapping.DefaultMethodName}({attr.Source.ToDisplayString()} source)
        {{
            return source.{sourceProp.Name};
        }}
        static partial void {mapping.MethodName}({attr.Source.ToDisplayString()} source, ref {targetProp.Type.ToDisplayString()} target);");
                }
                else
                {
                    mapping.MethodCode.AppendLine($@"
        private static partial {targetProp.Type.ToDisplayString()} {mapping.MethodName}({attr.Source.ToDisplayString()} source);");
                }
            }

            mappings.Add(mapping);
        }
    
        return mappings;
    }
    #endregion

    private static bool IsPropertyIgnored(IPropertySymbol property, FrozenSet<string> ignoredProperties)
    {
        return ignoredProperties.TryGetValue(property.Name, out _);
    }
}
