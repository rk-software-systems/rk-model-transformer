using Microsoft.CodeAnalysis;
using RKSoftware.Packages.ModelTransformer.Helpers;
using RKSoftware.Packages.ModelTransformer.Models;

namespace RKSoftware.Packages.ModelTransformer.Generations;

internal static class ModelExtensionGeneration
{
    public static string GenerateExtensionClass (string hostNamespace, AttributeDataModel attr)
    {
        var source = attr.Source;
        var target = attr.Target;

        var ignoredProperties = attr.IgnoredProperties;

        var variableCreationCode = string.Empty;
        var methodsCode = string.Empty;
        var variableMappingCode = string.Empty;

        var mappings = GeneratePropertyMappings(source, target);

        if (mappings.Count > 0)
        {
            variableCreationCode = mappings.Select(x => x.VariableCreationCode).Aggregate((a, b) => a.AppendLine(b.ToString())).ToString();
            methodsCode = mappings.Select(x => x.MethodCode).Aggregate((a, b) => a.AppendLine(b.ToString())).ToString();
            variableMappingCode = mappings.Select(x => x.VariableMappingCode).Aggregate((a, b) => a.AppendLine(b.ToString())).ToString();
        }

        var str = $@"
// <auto-generated>
#nullable enable

namespace {hostNamespace}
{{
    public static partial class {source.Name}Extensions
    {{
        public static {target.ToDisplayString()} Transform(this {source.ToDisplayString()} source)
        {{
            if (source == null) 
            {{
                throw new System.ArgumentNullException(nameof(source));
            }}
{variableCreationCode}
            var target = new {target.ToDisplayString()}
            {{
{variableMappingCode}
            }};
            return target;
        }}
{methodsCode}
    }}    
}}";
        return str;
    }    

    #region helpers

    private static List<PropertyMappingModel> GeneratePropertyMappings(ITypeSymbol source, ITypeSymbol target)
    {
        var mappings = new List<PropertyMappingModel>();
        foreach (var sourceProp in source.GetMembers().OfType<IPropertySymbol>())
        {
            var targetProp = target.GetMembers()
                .OfType<IPropertySymbol>()
                .FirstOrDefault(p => p.Name == sourceProp.Name && SymbolEqualityComparer.Default.Equals(p.Type, sourceProp.Type));

            if (targetProp != null && !sourceProp.IsStatic && !targetProp.IsStatic && targetProp.SetMethod != null)
            {
                var mapping = new PropertyMappingModel
                {
                    PropertyName = targetProp.Name,
                    VariableName = StringHelper.LowerCaseFirstLetter(targetProp.Name)
                };
                
                var defaultMethodName = $"To{mapping.PropertyName}Default";
                var methodName = $"To{mapping.PropertyName}";

                mapping.VariableCreationCode.AppendLine(@$"
            var {mapping.VariableName} = {defaultMethodName}(source);
            {methodName}(source, ref {mapping.VariableName});");

                mapping.VariableMappingCode.Append($@"
                {mapping.PropertyName} = {mapping.VariableName},");

                mapping.MethodCode.AppendLine($@"
        private static {targetProp.Type.ToDisplayString()} {defaultMethodName}({source.ToDisplayString()} source)
        {{
            return source.{sourceProp.Name};
        }}
        static partial void {methodName}({source.ToDisplayString()} source, ref {targetProp.Type.ToDisplayString()} target);");

                mappings.Add(mapping);
            }
        }
        return mappings;
    }
    #endregion
}
