# Model Transformer
Helps to transform one model to another. 
It generates extension methods for source model to transform it to the target model based on the registration class decorated with the `[ModelTransformerRegistration]` attribute.
It maps only public properties with the same name from source to target model by default. For properties that need custom mapping logic, it generates partial methods that should be implemented in another partial class.

| Package									| Version					                                                    |  Information                   | 
|-------------------------------------------|-------------------------------------------------------------------------------|--------------------------------|
|  RKSoftware.Packages.ModelTransformer     | ![NuGet](https://img.shields.io/nuget/v/RKSoftware.Packages.ModelTransformer) | [![CI](https://github.com/rk-software-systems/rk-model-transformer/actions/workflows/ci.yml/badge.svg)](https://github.com/rk-software-systems/rk-model-transformer/actions/workflows/ci.yml)

## Setup
1) To install the package, run the following command in the Package Manager Console:
```
Install-Package RKSoftware.Packages.ModelTransformer
```
Or via .NET CLI:
```
dotnet add package RKSoftware.Packages.ModelTransformer
```
Or via NuGet Package Manager, search for `RKSoftware.Packages.ModelTransformer` and install it.

2) Add `OutputItemType="Analyzer" ReferenceOutputAssembly="false"` to the package reference in your project file:
```xml
<PackageReference Include="RKSoftware.Packages.ModelTransformer" Version="x.y.z" OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
```

## Usage
1) Create registration class under your namespace and use the `[ModelTransformerRegistration]` attribute to specify source `YourDomain` and target `YourViewModel` models for transformation:
```csharp
using RKSoftware.Packages.ModelTransformer.Attributes;

namespace YourNamespace;

[ModelTransformerRegistration<YourDomain, YourViewModel>(
    Ignored = [nameof(YourViewModel.YourPropertyToIgnore)],
    WithoutDefaultMapping = [nameof(YourViewModel.YourPropertyWithoutDefaultMapping)]
)]
public class YourTransformerRegistration
{
}
```
where 
- `Ignored` - list of property names in the target model that should be ignored during the transformation,
- `WithoutDefaultMapping` - list of property names in the target model that should not use default mapping.

It generates the static partial class `YourDomainExtensions` with the `YourDomain` extension methods under the namespace `YourNamespace` in the file `YourNamespace.YourDomain.g.cs`.
If `YourDomain` is
```csharp
public class YourDomain
{
    public string? YourPropertyToMap { get; set; }

    public string? YourPropertyWithoutDefaultMapping { get; set; }

    public int? YourPropertyWithTypeMismatch { get; set; }
}
```
and `YourViewModel` is
```csharp
public class YourViewModel
{
    public string? YourPropertyToMap { get; set; }

    public string? YourPropertyWithoutDefaultMapping { get; set; }

    public string? YourPropertyToIgnore { get; set; }

    public string? YourPropertyWithTypeMismatch { get; set; }
}
```
then auto generated code is:
```csharp
// <auto-generated>
#nullable enable

namespace YourNamespace
{
    public static partial class YourDomainExtensions
    {
        public static YourViewModel Transform(this YourDomain source, YourViewModel? target = null)
        {
            if (source == null) 
			{
				throw new System.ArgumentNullException(nameof(source));
			}

            var yourPropertyToMap = ToYourViewModelYourPropertyToMapDefault(source);
			ToYourViewModelYourPropertyToMap(source, ref yourPropertyToMap);

            var yourPropertyWithoutDefaultMapping = ToYourViewModelYourPropertyWithoutDefaultMapping(source);

            var yourPropertyWithTypeMismatch = ToYourViewModelYourPropertyWithTypeMismatch(source);

            if (target == null)
			{
                target = new YourViewModel()
                {
                    YourPropertyToMap = yourPropertyToMap,
                    YourPropertyWithoutDefaultMapping = yourPropertyWithoutDefaultMapping,
                    YourPropertyWithTypeMismatch = yourPropertyWithTypeMismatch
                };
            }
            else
			{
                target.YourPropertyToMap = yourPropertyToMap;
                target.YourPropertyWithoutDefaultMapping = yourPropertyWithoutDefaultMapping;
                target.YourPropertyWithTypeMismatch = yourPropertyWithTypeMismatch;
            }
            return target;
        }

        private static string? ToYourViewModelYourPropertyToMapDefault(YourDomain source)
		{
			return source.YourPropertyToMap;
		}
		static partial void ToYourViewModelYourPropertyToMap(YourDomain source, ref string? target);


        private static partial string? ToYourViewModelYourPropertyWithoutDefaultMapping(YourDomain source);

        private static partial string? ToYourViewModelYourPropertyWithTypeMismatch(YourDomain source);
    }   
}

```
2) Create the static partial class `YourDomainExtensions` under the same namespace `YourNamespace` in another file to implement:
- custom mapping logic for properties listed in `WithoutDefaultMapping`.
  Required. If not implemented, a compilation error will occur:
  ```
  CS8795. Partial method 'MyDomainExtensions.ToYourViewModelYourPropertyWithoutDefaultMapping(YourDomain)' must have an implementation part because it has accessibility modifiers.
  ```
- custom mapping logic for properties with type mismatch.
  Required. If not implemented, a compilation error will occur:
  ```
  CS8795. Partial method 'MyDomainExtensions.ToYourViewModelYourPropertyWithTypeMismatch(YourDomain)' must have an implementation part because it has accessibility modifiers.
  ```  
- custom mapping logic after default mapping logic for other properties.
  Optional. If not implemented, no compilation error will occur.

```csharp
namespace YourNamespace; 


public static partial class YourDomainExtensions
{
    // custom mapping logic for properties listed in `WithoutDefaultMapping` (required)
    private static partial string? ToYourViewModelYourPropertyWithoutDefaultMapping(YourDomain source)
    {
        return source.YourPropertyWithoutDefaultMapping;
    }

    // custom mapping logic for properties with type mismatch (required)
    private static partial string? ToYourViewModelYourPropertyWithTypeMismatch(YourDomain source)
    {
        return source.YourPropertyWithTypeMismatch?.ToString(CultureInfo.InvariantCulture);
    }

    // custom mapping logic after default mapping logic for other properties (optional)
    static partial void ToYourViewModelYourPropertyToMap(YourDomain source, ref string? target)
    {
        if (!string.IsNullOrEmpty(target))
        {
            target = target + " - Transformed";
        }
    }
}

```
3) Generated files `.g.cs` can be found YourProject -> Dependencies -> Analyzers -> RKSoftware.Packages.ModelTransformer

## Mapping table
There are several types of mappings supported automatically in `..Default` method:

<table>
  <thead>
    <tr><th>Type</th><th>From → To</th><th></th></tr>
  </thead>
  <tbody>
    <tr><td rowspan="4">Primitive (or Structure)</td><td>int → int?</td><td>✅</td></tr>
    <tr><td>int → long</td><td>✅</td></tr>
    <tr><td>int? → int</td><td>❌</td></tr>
    <tr><td>long → int</td><td>❌</td></tr>
    <tr><td rowspan="2">Class</td><td>YourDomain → YourViewModel?</td><td>✅</td></tr>
    <tr><td>YourDomain? → YourViewModel</td><td>❌</td></tr>
    <tr><td rowspan="4">Primitive (or Structure) generic type parameter in generic enumerables</td><td>ICollection&lt;int&gt; → ICollection&lt;int?&gt;</td><td>✅</td></tr>
    <tr><td>ICollection&lt;int&gt; → ICollection&lt;long&gt;</td><td>✅</td></tr>
    <tr><td>ICollection&lt;int?&gt; → ICollection&lt;int&gt;</td><td>❌</td></tr>
    <tr><td>ICollection&lt;long&gt; → ICollection&lt;int&gt;</td><td>❌</td></tr>
    <tr><td rowspan="2">Class generic type parameter in generic enumerables, if registration YourDomain → YourViewModel exists</td><td>ICollection&lt;YourDomain&gt; → ICollection&lt;YourViewModel?&gt;</td><td>✅</td></tr>
    <tr><td>ICollection&lt;YourDomain?&gt; → ICollection&lt;YourViewModel&gt;</td><td>❌</td></tr>
  </tbody>
</table>